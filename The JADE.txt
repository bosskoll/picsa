
// frontend/src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import store from './store';
import './index.css';
import { ThemeProvider } from './contexts/ThemeContext';
import { AuthProvider } from './contexts/AuthContext';

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <BrowserRouter>
        <ThemeProvider>
          <AuthProvider>
            <App />
          </AuthProvider>
        </ThemeProvider>
      </BrowserRouter>
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);
```

```javascript
// frontend/src/App.js
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import Dashboard from './pages/Dashboard';
import Login from './pages/Login';
import Register from './pages/Register';
import ScanResults from './pages/ScanResults';
import Reports from './pages/Reports';
import Settings from './pages/Settings';
import PasswordReset from './pages/PasswordReset';
import Profile from './pages/Profile';
import Helpdesk from './pages/Helpdesk';
import ProtectedRoute from './components/ProtectedRoute';
import Navbar from './components/Navbar';
import Footer from './components/Footer';
import { useAuth } from './contexts/AuthContext';
import { useTheme } from './contexts/ThemeContext';

function App() {
  const { isAuthenticated } = useAuth();
  const { theme } = useTheme();

  return (
    <div className={`app ${theme}`} role="application">
      <Navbar />
      <main className="main-content" role="main">
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route path="/register" element={<Register />} />
          <Route path="/reset-password" element={<PasswordReset />} />
          <Route
            path="/dashboard"
            element={
              <ProtectedRoute isAuthenticated={isAuthenticated}>
                <Dashboard />
              </ProtectedRoute>
            }
          />
          <Route
            path="/scan-results"
            element={
              <ProtectedRoute isAuthenticated={isAuthenticated}>
                <ScanResults />
              </ProtectedRoute>
            }
          />
          <Route
            path="/reports"
            element={
              <ProtectedRoute isAuthenticated={isAuthenticated}>
                <Reports />
              </ProtectedRoute>
            }
          />
          <Route
            path="/settings"
            element={
              <ProtectedRoute isAuthenticated={isAuthenticated}>
                <Settings />
              </ProtectedRoute>
            }
          />
          <Route
            path="/profile"
            element={
              <ProtectedRoute isAuthenticated={isAuthenticated}>
                <Profile />
              </ProtectedRoute>
            }
          />
          <Route
            path="/helpdesk"
            element={
              <ProtectedRoute isAuthenticated={isAuthenticated}>
                <Helpdesk />
              </ProtectedRoute>
            }
          />
          <Route path="*" element={<Login />} />
        </Routes>
      </main>
      <Footer />
    </div>
  );
}

export default App;
```

```javascript
// frontend/src/pages/Dashboard.js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchDashboardStats } from '../store/slices/dashboardSlice';
import ScanStatusCard from '../components/ScanStatusCard';
import VulnerabilityChart from '../components/VulnerabilityChart';
import ThreatIntelligenceCard from '../components/ThreatIntelligenceCard';
import { toast } from 'react-toastify';

function Dashboard() {
  const dispatch = useDispatch();
  const { stats, loading, error } = useSelector((state) => state.dashboard);

  useEffect(() => {
    dispatch(fetchDashboardStats())
      .unwrap()
      .catch((err) => toast.error(err.message || 'Failed to fetch dashboard stats'));
  }, [dispatch]);

  if (loading) return <div className="loading" aria-live="polite">Loading dashboard data...</div>;
  if (error) return <div className="error" aria-live="assertive">Error loading dashboard: {error}</div>;

  return (
    <div className="dashboard" role="region" aria-label="Dashboard">
      <h1>Dashboard</h1>
      <div className="cards-container">
        <ScanStatusCard totalScans={stats.totalScans || 0} activeScans={stats.activeScans || 0} />
        <VulnerabilityChart vulnerabilities={stats.vulnerabilities || {}} />
        <ThreatIntelligenceCard threats={stats.threats || []} />
      </div>
    </div>
  );
}

export default Dashboard;
```

```javascript
// frontend/src/pages/Login.js
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useNavigate } from 'react-router-dom';
import { toast } from 'react-toastify';
import { validateLoginForm } from '../utils/validation';

function Login() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [formData, setFormData] = useState({ username: '', password: '', mfaToken: '' });
  const [errors, setErrors] = useState({});
  const [isMFARequired, setIsMFARequired] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: '' }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const validationErrors = validateLoginForm(formData);
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      const response = await login(formData.username, formData.password, formData.mfaToken);
      if (response.status === 206) {
        setIsMFARequired(true);
        toast.info('Please enter your MFA token');
      } else {
        navigate('/dashboard', { replace: true });
        toast.success('Logged in successfully');
      }
    } catch (error) {
      setErrors({ form: error.message || 'Login failed. Please check your credentials.' });
      toast.error(error.message || 'Login failed');
    }
  };

  return (
    <div className="login-page" role="region" aria-label="Login">
      <form onSubmit={handleSubmit} className="login-form" noValidate>
        <h2>Login</h2>
        {errors.form && <div className="error" aria-live="assertive">{errors.form}</div>}
        <div className="form-group">
          <label htmlFor="username">Username</label>
          <input
            type="text"
            id="username"
            name="username"
            value={formData.username}
            onChange={handleChange}
            aria-invalid={!!errors.username}
            aria-describedby={errors.username ? 'username-error' : undefined}
            required
          />
          {errors.username && <span id="username-error" className="error">{errors.username}</span>}
        </div>
        <div className="form-group">
          <label htmlFor="password">Password</label>
          <input
            type="password"
            id="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            aria-invalid={!!errors.password}
            aria-describedby={errors.password ? 'password-error' : undefined}
            required
          />
          {errors.password && <span id="password-error" className="error">{errors.password}</span>}
        </div>
        {isMFARequired && (
          <div className="form-group">
            <label htmlFor="mfaToken">MFA Token</label>
            <input
              type="text"
              id="mfaToken"
              name="mfaToken"
              value={formData.mfaToken}
              onChange={handleChange}
              aria-invalid={!!errors.mfaToken}
              aria-describedby={errors.mfaToken ? 'mfaToken-error' : undefined}
              required
            />
            {errors.mfaToken && <span id="mfaToken-error" className="error">{errors.mfaToken}</span>}
          </div>
        )}
        <button type="submit" disabled={Object.keys(errors).length > 0}>Login</button>
      </form>
    </div>
  );
}

export default Login;
```

```javascript
// frontend/src/pages/Register.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import { toast } from 'react-toastify';
import { validateRegisterForm } from '../utils/validation';

function Register() {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({ username: '', email: '', password: '', fullName: '' });
  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: '' }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const validationErrors = validateRegisterForm(formData);
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      const response = await axios.post('/api/v1/auth/register', formData, {
        headers: { 'Content-Type': 'application/json' },
      });
      toast.success('Registration successful. Please log in.');
      navigate('/login', { replace: true });
    } catch (error) {
      const message = error.response?.data?.detail || 'Registration failed. Please try again.';
      setErrors({ form: message });
      toast.error(message);
    }
  };

  return (
    <div className="register-page" role="region" aria-label="Register">
      <form onSubmit={handleSubmit} className="register-form" noValidate>
        <h2>Register</h2>
        {errors.form && <div className="error" aria-live="assertive">{errors.form}</div>}
        <div className="form-group">
          <label htmlFor="username">Username</label>
          <input
            type="text"
            id="username"
            name="username"
            value={formData.username}
            onChange={handleChange}
            aria-invalid={!!errors.username}
            aria-describedby={errors.username ? 'username-error' : undefined}
            required
          />
          {errors.username && <span id="username-error" className="error">{errors.username}</span>}
        </div>
        <div className="form-group">
          <label htmlFor="email">Email</label>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            aria-invalid={!!errors.email}
            aria-describedby={errors.email ? 'email-error' : undefined}
            required
          />
          {errors.email && <span id="email-error" className="error">{errors.email}</span>}
        </div>
        <div className="form-group">
          <label htmlFor="password">Password</label>
          <input
            type="password"
            id="password"
            name="password"
            value={formData.password}
            onChange={handleChange}
            aria-invalid={!!errors.password}
            aria-describedby={errors.password ? 'password-error' : undefined}
            required
          />
          {errors.password && <span id="password-error" className="error">{errors.password}</span>}
        </div>
        <div className="form-group">
          <label htmlFor="fullName">Full Name</label>
          <input
            type="text"
            id="fullName"
            name="fullName"
            value={formData.fullName}
            onChange={handleChange}
            aria-invalid={!!errors.fullName}
            aria-describedby={errors.fullName ? 'fullName-error' : undefined}
            required
          />
          {errors.fullName && <span id="fullName-error" className="error">{errors.fullName}</span>}
        </div>
        <button type="submit" disabled={Object.keys(errors).length > 0}>Register</button>
      </form>
    </div>
  );
}

export default Register;
```

```javascript
// frontend/src/pages/ScanResults.js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchScanResults } from '../store/slices/scanSlice';
import { toast } from 'react-toastify';

function ScanResults() {
  const dispatch = useDispatch();
  const { scans, loading, error } = useSelector((state) => state.scan);

  useEffect(() => {
    dispatch(fetchScanResults())
      .unwrap()
      .catch((err) => toast.error(err.message || 'Failed to fetch scan results'));
  }, [dispatch]);

  if (loading) return <div className="loading" aria-live="polite">Loading scan results...</div>;
  if (error) return <div className="error" aria-live="assertive">Error loading scan results: {error}</div>;

  return (
    <div className="scan-results" role="region" aria-label="Scan Results">
      <h1>Scan Results</h1>
      {scans.length === 0 ? (
        <p>No scan results available.</p>
      ) : (
        <table className="scan-table" role="grid">
          <thead>
            <tr>
              <th scope="col">ID</th>
              <th scope="col">Target</th>
              <th scope="col">Scan Type</th>
              <th scope="col">Status</th>
              <th scope="col">Total Findings</th>
            </tr>
          </thead>
          <tbody>
            {scans.map((scan) => (
              <tr key={scan.id}>
                <td>{scan.id}</td>
                <td>{scan.target}</td>
                <td>{scan.scan_type}</td>
                <td>{scan.status}</td>
                <td>{scan.total_findings}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default ScanResults;
```

```javascript
// frontend/src/pages/Reports.js
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchReports } from '../store/slices/reportSlice';
import { toast } from 'react-toastify';
import axios from 'axios';

function Reports() {
  const dispatch = useDispatch();
  const { reports, loading, error } = useSelector((state) => state.report);
  const [reportType, setReportType] = useState('executive');

  useEffect(() => {
    dispatch(fetchReports())
      .unwrap()
      .catch((err) => toast.error(err.message || 'Failed to fetch reports'));
  }, [dispatch]);

  const handleDownload = async (scanId) => {
    try {
      const response = await axios.get(`/api/v1/reports/${scanId}?report_type=${reportType}`, {
        responseType: 'blob',
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      const url = window.URL.createObjectURL(new Blob([response.data], { type: 'application/pdf' }));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `report_${scanId}_${reportType}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();
      window.URL.revokeObjectURL(url);
      toast.success('Report downloaded successfully');
    } catch (error) {
      toast.error('Failed to download report. Please try again.');
    }
  };

  if (loading) return <div className="loading" aria-live="polite">Loading reports...</div>;
  if (error) return <div className="error" aria-live="assertive">Error loading reports: {error}</div>;

  return (
    <div className="reports" role="region" aria-label="Reports">
      <h1>Reports</h1>
      <div className="form-group">
        <label htmlFor="reportType">Report Type</label>
        <select
          id="reportType"
          value={reportType}
          onChange={(e) => setReportType(e.target.value)}
          aria-label="Select report type"
        >
          <option value="executive">Executive</option>
          <option value="technical">Technical</option>
        </select>
      </div>
      {reports.length === 0 ? (
        <p>No reports available.</p>
      ) : (
        <table className="reports-table" role="grid">
          <thead>
            <tr>
              <th scope="col">Scan ID</th>
              <th scope="col">Target</th>
              <th scope="col">Action</th>
            </tr>
          </thead>
          <tbody>
            {reports.map((report) => (
              <tr key={report.scan_id}>
                <td>{report.scan_id}</td>
                <td>{report.target}</td>
                <td>
                  <button onClick={() => handleDownload(report.scan_id)} aria-label={`Download report for scan ${report.scan_id}`}>
                    Download
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default Reports;
```

```javascript
// frontend/src/pages/Settings.js
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import axios from 'axios';
import { toast } from 'react-toastify';
import { validateSettingsForm } from '../utils/validation';

function Settings() {
  const { user } = useAuth();
  const [formData, setFormData] = useState({ mfaEnabled: user?.mfa_enabled || false });
  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, checked } = e.target;
    setFormData((prev) => ({ ...prev, [name]: checked }));
    setErrors((prev) => ({ ...prev, [name]: '' }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const validationErrors = validateSettingsForm(formData);
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      await axios.put('/api/v1/auth/settings', formData, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      toast.success('Settings updated successfully');
    } catch (error) {
      const message = error.response?.data?.detail || 'Failed to update settings. Please try again.';
      setErrors({ form: message });
      toast.error(message);
    }
  };

  return (
    <div className="settings-page" role="region" aria-label="Settings">
      <form onSubmit={handleSubmit} className="settings-form" noValidate>
        <h2>Settings</h2>
        {errors.form && <div className="error" aria-live="assertive">{errors.form}</div>}
        <div className="form-group">
          <label htmlFor="mfaEnabled">Enable Multi-Factor Authentication (MFA)</label>
          <input
            type="checkbox"
            id="mfaEnabled"
            name="mfaEnabled"
            checked={formData.mfaEnabled}
            onChange={handleChange}
            aria-invalid={!!errors.mfaEnabled}
            aria-describedby={errors.mfaEnabled ? 'mfaEnabled-error' : undefined}
          />
          {errors.mfaEnabled && <span id="mfaEnabled-error" className="error">{errors.mfaEnabled}</span>}
        </div>
        <button type="submit" disabled={Object.keys(errors).length > 0}>Save Settings</button>
      </form>
    </div>
  );
}

export default Settings;
```

```javascript
// frontend/src/pages/PasswordReset.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import { toast } from 'react-toastify';
import { validateEmail } from '../utils/validation';

function PasswordReset() {
  const [email, setEmail] = useState('');
  const [errors, setErrors] = useState({});
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    const validationErrors = validateEmail({ email });
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      await axios.post('/api/v1/auth/reset-password-request', { email }, {
        headers: { 'Content-Type': 'application/json' },
      });
      toast.success('Password reset link sent to your email.');
      navigate('/login', { replace: true });
    } catch (error) {
      const message = error.response?.data?.detail || 'Failed to send reset link. Please try again.';
      setErrors({ form: message });
      toast.error(message);
    }
  };

  return (
    <div className="password-reset-page" role="region" aria-label="Password Reset">
      <form onSubmit={handleSubmit} className="password-reset-form" noValidate>
        <h2>Password Reset</h2>
        {errors.form && <div className="error" aria-live="assertive">{errors.form}</div>}
        <div className="form-group">
          <label htmlFor="email">Email</label>
          <input
            type="email"
            id="email"
            name="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            aria-invalid={!!errors.email}
            aria-describedby={errors.email ? 'email-error' : undefined}
            required
          />
          {errors.email && <span id="email-error" className="error">{errors.email}</span>}
        </div>
        <button type="submit" disabled={Object.keys(errors).length > 0}>Send Reset Link</button>
      </form>
    </div>
  );
}

export default PasswordReset;
```

```javascript
// frontend/src/pages/Profile.js
import React, { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import axios from 'axios';
import { toast } from 'react-toastify';
import { validateProfileForm } from '../utils/validation';

function Profile() {
  const { isAuthenticated, user } = useAuth();
  const [formData, setFormData] = useState({ fullName: '', email: '' });
  const [errors, setErrors] = useState({});

  useEffect(() => {
    if (isAuthenticated && user) {
      setFormData({ fullName: user.full_name || '', email: user.email || '' });
    }
  }, [isAuthenticated, user]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: '' }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const validationErrors = validateProfileForm(formData);
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      await axios.put('/api/v1/auth/me', formData, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      toast.success('Profile updated successfully');
    } catch (error) {
      const message = error.response?.data?.detail || 'Failed to update profile. Please try again.';
      setErrors({ form: message });
      toast.error(message);
    }
  };

  return (
    <div className="profile-page" role="region" aria-label="Profile">
      <form onSubmit={handleSubmit} className="profile-form" noValidate>
        <h2>Profile</h2>
        {errors.form && <div className="error" aria-live="assertive">{errors.form}</div>}
        <div className="form-group">
          <label htmlFor="fullName">Full Name</label>
          <input
            type="text"
            id="fullName"
            name="fullName"
            value={formData.fullName}
            onChange={handleChange}
            aria-invalid={!!errors.fullName}
            aria-describedby={errors.fullName ? 'fullName-error' : undefined}
            required
          />
          {errors.fullName && <span id="fullName-error" className="error">{errors.fullName}</span>}
        </div>
        <div className="form-group">
          <label htmlFor="email">Email</label>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            aria-invalid={!!errors.email}
            aria-describedby={errors.email ? 'email-error' : undefined}
            required
          />
          {errors.email && <span id="email-error" className="error">{errors.email}</span>}
        </div>
        <button type="submit" disabled={Object.keys(errors).length > 0}>Update Profile</button>
      </form>
    </div>
  );
}

export default Profile;
```

```javascript
// frontend/src/pages/Helpdesk.js
import React, { useState } from 'react';
import axios from 'axios';
import { toast } from 'react-toastify';
import { validateTicketForm } from '../utils/validation';

function Helpdesk() {
  const [formData, setFormData] = useState({ subject: '', details: '' });
  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => ({ ...prev, [name]: '' }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const validationErrors = validateTicketForm(formData);
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      await axios.post('/api/v1/helpdesk/ticket', formData, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      toast.success('Support ticket submitted successfully');
      setFormData({ subject: '', details: '' });
    } catch (error) {
      const message = error.response?.data?.detail || 'Failed to submit ticket. Please try again.';
      setErrors({ form: message });
      toast.error(message);
    }
  };

  return (
    <div className="helpdesk-page" role="region" aria-label="Helpdesk">
      <form onSubmit={handleSubmit} className="helpdesk-form" noValidate>
        <h2>Submit a Support Ticket</h2>
        {errors.form && <div className="error" aria-live="assertive">{errors.form}</div>}
        <div className="form-group">
          <label htmlFor="subject">Subject</label>
          <input
            type="text"
            id="subject"
            name="subject"
            value={formData.subject}
            onChange={handleChange}
            aria-invalid={!!errors.subject}
            aria-describedby={errors.subject ? 'subject-error' : undefined}
            required
          />
          {errors.subject && <span id="subject-error" className="error">{errors.subject}</span>}
        </div>
        <div className="form-group">
          <label htmlFor="details">Details</label>
          <textarea
            id="details"
            name="details"
            value={formData.details}
            onChange={handleChange}
            aria-invalid={!!errors.details}
            aria-describedby={errors.details ? 'details-error' : undefined}
            required
          />
          {errors.details && <span id="details-error" className="error">{errors.details}</span>}
        </div>
        <button type="submit" disabled={Object.keys(errors).length > 0}>Submit Ticket</button>
      </form>
    </div>
  );
}

export default Helpdesk;
```

```javascript
// frontend/src/components/Navbar.js
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';
import { toast } from 'react-toastify';

function Navbar() {
  const { isAuthenticated, logout } = useAuth();
  const { theme, toggleTheme } = useTheme();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    toast.success('Logged out successfully');
    navigate('/login', { replace: true });
  };

  return (
    <nav className={`navbar ${theme}`} role="navigation" aria-label="Main navigation">
      <div className="logo">
        <Link to="/" aria-label="JADE Ultimate Home">JADE Ultimate</Link>
      </div>
      <ul className="nav-links">
        {isAuthenticated ? (
          <>
            <li><Link to="/dashboard">Dashboard</Link></li>
            <li><Link to="/scan-results">Scan Results</Link></li>
            <li><Link to="/reports">Reports</Link></li>
            <li><Link to="/settings">Settings</Link></li>
            <li><Link to="/profile">Profile</Link></li>
            <li><Link to="/helpdesk">Helpdesk</Link></li>
            <li><button onClick={handleLogout} aria-label="Logout">Logout</button></li>
          </>
        ) : (
          <>
            <li><Link to="/login">Login</Link></li>
            <li><Link to="/register">Register</Link></li>
            <li><Link to="/reset-password">Password Reset</Link></li>
          </>
        )}
      </ul>
      <button onClick={toggleTheme} className="theme-toggle" aria-label={`Switch to ${theme === 'light' ? 'Dark' : 'Light'} Mode`}>
        Switch to {theme === 'light' ? 'Dark' : 'Light'} Mode
      </button>
    </nav>
  );
}

export default Navbar;
```

```javascript
// frontend/src/components/Footer.js
import React from 'react';
import { useTheme } from '../contexts/ThemeContext';

function Footer() {
  const { theme } = useTheme();

  return (
    <footer className={`footer ${theme}`} role="contentinfo">
      <p>&copy; 2025 JADE Ultimate. All rights reserved.</p>
      <ul className="footer-links">
        <li><a href="/privacy-policy" aria-label="Privacy Policy">Privacy Policy</a></li>
        <li><a href="/terms-of-service" aria-label="Terms of Service">Terms of Service</a></li>
        <li><a href="/support" aria-label="Support">Support</a></li>
      </ul>
    </footer>
  );
}

export default Footer;
```

```javascript
// frontend/src/components/ScanStatusCard.js
import React from 'react';

function ScanStatusCard({ totalScans, activeScans }) {
  const percentage = totalScans > 0 ? (activeScans / totalScans) * 100 : 0;

  return (
    <div className="card scan-status" role="region" aria-label="Scan Status">
      <h3>Scan Status</h3>
      <p>Total Scans: {totalScans}</p>
      <p>Active Scans: {activeScans}</p>
      <div className="progress-bar" role="progressbar" aria-valuenow={percentage} aria-valuemin="0" aria-valuemax=" beauties100">
        <div className="progress" style={{ width: `${percentage}%` }}></div>
      </div>
    </div>
  );
}

export default ScanStatusCard;
```

```javascript
// frontend/src/components/VulnerabilityChart.js
import React, { useEffect, useRef } from 'react';
import Chart from 'chart.js/auto';

function VulnerabilityChart({ vulnerabilities }) {
  const chartRef = useRef(null);
  const chartInstance = useRef(null);

  useEffect(() => {
    if (chartRef.current) {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }

      const ctx = chartRef.current.getContext('2d');
      chartInstance.current = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: Object.keys(vulnerabilities),
          datasets: [{
            label: 'Vulnerabilities',
            data: Object.values(vulnerabilities),
            backgroundColor: ['#dc3545', '#fd7e14', '#ffc107', '#28a745', '#17a2b8'],
          }],
        },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'top' },
            title: { display: false },
          },
        },
      });
    }

    return () => {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }
    };
  }, [vulnerabilities]);

  return (
    <div className="card vulnerability-chart" role="region" aria-label="Vulnerability Distribution">
      <h3>Vulnerability Distribution</h3>
      <div className="chart-container">
        <canvas ref={chartRef} id="vulnerabilityChart" aria-label="Chart showing vulnerability distribution"></canvas>
      </div>
    </div>
  );
}

export default VulnerabilityChart;
```

```javascript
// frontend/src/components/ThreatIntelligenceCard.js
import React from 'react';

function ThreatIntelligenceCard({ threats }) {
  return (
    <div className="card threat-intelligence" role="region" aria-label="Threat Intelligence">
      <h3>Threat Intelligence</h3>
      {threats.length === 0 ? (
        <p>No threats detected.</p>
      ) : (
        <ul>
          {threats.map((threat, index) => (
            <li key={index}>
              {threat.threat_actor}: <span className="risk-level">{threat.risk_level}</span>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default ThreatIntelligenceCard;
```

```javascript
// frontend/src/components/ProtectedRoute.js
import React from 'react';
import { Navigate } from 'react-router-dom';

function ProtectedRoute({ isAuthenticated, children }) {
  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }
  return children;
}

export default ProtectedRoute;
```

```javascript
// frontend/src/contexts/ThemeContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState(() => localStorage.getItem('theme') || 'light');

  const toggleTheme = () => {
    setTheme((prevTheme) => {
      const newTheme = prevTheme === 'light' ? 'dark' : 'light';
      localStorage.setItem('theme', newTheme);
      return newTheme;
    });
  };

  useEffect(() => {
    document.body.className = theme;
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) throw new Error('useTheme must be used within a ThemeProvider');
  return context;
};
```

```javascript
// frontend/src/contexts/AuthContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(() => !!localStorage.getItem('token'));
  const [user, setUser] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchUser = async () => {
      const token = localStorage.getItem('token');
      if (token) {
        try {
          const response = await axios.get('/api/v1/auth/me', {
            headers: { Authorization: `Bearer ${token}` },
          });
          setUser(response.data);
          setIsAuthenticated(true);
        } catch (error) {
          setIsAuthenticated(false);
          setUser(null);
          localStorage.removeItem('token');
        }
      }
    };
    fetchUser();
  }, []);

  const login = async (username, password, mfaToken = '') => {
    const response = await axios.post('/api/v1/auth/login', { username, password, mfaToken }, {
      headers: { 'Content-Type': 'application/json' },
    });
    localStorage.setItem('token', response.data.access_token);
    setIsAuthenticated(true);
    setUser(response.data.user);
    return response;
  };

  const logout = () => {
    localStorage.removeItem('token');
    setIsAuthenticated(false);
    setUser(null);
    navigate('/login', { replace: true });
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within an AuthProvider');
  return context;
};
```

```javascript
// frontend/src/store/index.js
import { configureStore } from '@reduxjs/toolkit';
import dashboardReducer from './slices/dashboardSlice';
import scanReducer from './slices/scanSlice';
import reportReducer from './slices/reportSlice';

const store = configureStore({
  reducer: {
    dashboard: dashboardReducer,
    scan: scanReducer,
    report: reportReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }),
});

export default store;
```

```javascript
// frontend/src/store/slices/dashboardSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

export const fetchDashboardStats = createAsyncThunk(
  'dashboard/fetchStats',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get('/api/v1/dashboard/stats', {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch dashboard stats');
    }
  }
);

const dashboardSlice = createSlice({
  name: 'dashboard',
  initialState: {
    stats: { totalScans: 0, activeScans: 0, vulnerabilities: {}, threats: [] },
    loading: false,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchDashboardStats.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchDashboardStats.fulfilled, (state, action) => {
        state.loading = false;
        state.stats = action.payload;
      })
      .addCase(fetchDashboardStats.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export default dashboardSlice.reducer;
```

```javascript
// frontend/src/store/slices/scanSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

export const fetchScanResults = createAsyncThunk(
  'scan/fetchResults',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get('/api/v1/scans', {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch scan results');
    }
  }
);

const scanSlice = createSlice({
  name: 'scan',
  initialState: {
    scans: [],
    loading: false,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchScanResults.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchScanResults.fulfilled, (state, action) => {
        state.loading = false;
        state.scans = action.payload;
      })
      .addCase(fetchScanResults.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export default scanSlice.reducer;
```

```javascript
// frontend/src/store/slices/reportSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

export const fetchReports = createAsyncThunk(
  'report/fetchReports',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get('/api/v1/reports', {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch reports');
    }
  }
);

const reportSlice = createSlice({
  name: 'report',
  initialState: {
    reports: [],
    loading: false,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchReports.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchReports.fulfilled, (state, action) => {
        state.loading = false;
        state.reports = action.payload;
      })
      .addCase(fetchReports.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export default reportSlice.reducer;
```

```javascript
// frontend/src/utils/validation.js
export const validateLoginForm = (formData) => {
  const errors = {};
  if (!formData.username.trim()) errors.username = 'Username is required';
  if (!formData.password.trim()) errors.password = 'Password is required';
  if (formData.mfaToken && !/^\d{6}$/.test(formData.mfaToken))
    errors.mfaToken = 'MFA token must be a 6-digit number';
  return errors;
};

export const validateRegisterForm = (formData) => {
  const errors = {};
  if (!formData.username.trim()) errors.username = 'Username is required';
  else if (formData.username.length < 3) errors.username = 'Username must be at least 3 characters';
  if (!formData.email.trim()) errors.email = 'Email is required';
  else if (!/\S+@\S+\.\S+/.test(formData.email)) errors.email = 'Invalid email format';
  if (!formData.password.trim()) errors.password = 'Password is required';
  else if (formData.password.length < 8) errors.password = 'Password must be at least 8 characters';
  else if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(formData.password))
    errors.password = 'Password must contain uppercase, lowercase, and a number';
  if (!formData.fullName.trim()) errors.fullName = 'Full name is required';
  return errors;
};

export const validateEmail = (data) => {
  const errors = {};
  if (!data.email.trim()) errors.email = 'Email is required';
  else if (!/\S+@\S+\.\S+/.test(data.email)) errors.email = 'Invalid email format';
  return errors;
};

export const validateProfileForm = (data) => {
  const errors = {};
  if (!data.fullName.trim()) errors.fullName = 'Full name is required';
  if (!data.email.trim()) errors.email = 'Email is required';
  else if (!/\S+@\S+\.\S+/.test(data.email)) errors.email = 'Invalid email format';
  return errors;
};

export const validateTicketForm = (data) => {
  const errors = {};
  if (!data.subject.trim()) errors.subject = 'Subject is required';
  else if (data.subject.length < 5) errors.subject = 'Subject must be at least 5 characters';
  if (!data.details.trim()) errors.details = 'Details are required';
  else if (data.details.length < 10) errors.details = 'Details must be at least 10 characters';
  return errors;
};

export const validateSettingsForm = (data) => {
  const errors = {};
  // Add specific validation if needed in the future
  return errors;
};
```

```css
// frontend/src/index.css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
    Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  transition: background-color 0.3s, color 0.3s;
}

.app.light {
  background-color: #f5f5f5;
  color: #333;
}

.app.dark {
  background-color: #1a1a1a;
  color: #f5f5f5;
}

.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 2rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.navbar.light {
  background-color: #fff;
}

.navbar.dark {
  background-color: #2c2c2c;
}

.nav-links {
  list-style: none;
  display: flex;
  gap: 1rem;
  margin: 0;
  padding: 0;
}

.nav-links li a, .nav-links li button {
  text-decoration: none;
  color: inherit;
  background: none;
  border: none;
  padding: 0.5rem;
  cursor: pointer;
}

.nav-links li button:hover {
  color: #007bff;
}

.footer {
  padding: 1rem;
  text-align: center;
  border-top: 1px solid #ccc;
  position: relative;
  bottom: 0;
  width: 100%;
}

.footer.light {
  background-color: #fff;
}

.footer.dark {
  background-color: #2c2c2c;
}

.footer-links {
  list-style: none;
  display: flex;
  justify-content: center;
  gap: 1rem;
  padding: 0;
}

.footer-links a {
  color: inherit;
  text-decoration: none;
}

.footer-links a:hover {
  text-decoration: underline;
}

.card {
  padding: 1.5rem;
  border-radius: 8px;
  margin-bottom: 1rem;
}

.card.light {
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.card.dark {
  background-color: #333;
  box-shadow: 0 2px 4px rgba(255, 255, 255, 0.1);
}

.loading {
  text-align: center;
  padding: 2rem;
  font-size: 1.1rem;
}

.error {
  color: #dc3545;
  text-align: center;
  padding: 1rem;
  font-size: 1rem;
}

.progress-bar {
  width: 100%;
  height: 20px;
  background-color: #e9ecef;
  border-radius: 10px;
  overflow: hidden;
}

.progress {
  height: 100%;
  background-color: #28a745;
  transition: width 0.3s ease-in-out;
}

.login-page, .register-page, .password-reset-page, .profile-page, .helpdesk-page, .settings-page {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 120px);
}

.login-form, .register-form, .password-reset-form, .profile-form, .helpdesk-form, .settings-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 400px;
}

.login-form.light, .register-form.light, .password-reset-form.light, .profile-form.light, .helpdesk-form.light, .settings-form.light {
  background-color: #fff;
}

.login-form.dark, .register-form.dark, .password-reset-form.dark, .profile-form.dark, .helpdesk-form.dark, .settings-form.dark {
  background-color: #2c2c2c;
}

.form-group {
  display: flex;
  flex-direction: column;
}

.form-group label {
  margin-bottom: 0.25rem;
  font-weight: 500;
}

.form-group input, .form-group textarea, .form-group select {
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 1rem;
}

.form-group textarea {
  min-height: 100px;
  resize: vertical;
}

.form-group input:focus, .form-group textarea:focus, .form-group select:focus {
  outline: 2px solid #007bff;
  border-color: #007bff;
}

.error {
  color: #dc3545;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}

button {
  padding: 0.75rem 1rem;
  background-color: #007bff;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s;
}

button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
}

button:hover:not(:disabled) {
  background-color: #0056b3;
}

button:focus {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}

.theme-toggle {
  padding: 0.5rem 1rem;
  background-color: #6c757d;
  color: #fff;
  border-radius: 4px;
}

.theme-toggle:hover {
  background-color: #5a6268;
}

.scan-table, .reports-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 1rem;
}

.scan-table th, .scan-table td, .reports-table th, .reports-table td {
  border: 1px solid #ccc;
  padding: 0.75rem;
  text-align: left;
}

.scan-table th, .reports-table th {
  background-color: #f8f9fa;
}

.scan-table.dark th, .reports-table.dark th {
  background-color: #444;
}

.risk-level {
  font-weight: 500;
}

@media (max-width: 768px) {
  .navbar {
    flex-direction: column;
    gap: 1rem;
    padding: 1rem;
  }

  .nav-links {
    flex-direction: column;
    align-items: center;
  }

  .login-form, .register-form, .password-reset-form, .profile-form, .helpdesk-form, .settings-form {
    padding: 1.5rem;
    max-width: 90%;
  }

  .scan-table, .reports-table {
    font-size: 0.875rem;
  }

  .scan-table th, .scan-table td, .reports-table th, .reports-table td {
    padding: 0.5rem;
  }
}

@media (prefers-reduced-motion: reduce) {
  .progress {
    transition: none;
  }
}
```

```python
# backend/app/main.py
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from app.api.v1.endpoints import auth, scans, vulnerabilities, reports, ai_analysis, dashboard, admin, helpdesk
from app.core.database import engine
from app.utils.logger import setup_logging
import structlog

logger = structlog.get_logger()

app = FastAPI(
    title="JADE Ultimate API",
    description="API for JADE Ultimate security scanning platform",
    version="1.0.0",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://jadeultimate.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(auth.router, prefix="/api/v1")
app.include_router(scans.router, prefix="/api/v1")
app.include_router(vulnerabilities.router, prefix="/api/v1")
app.include_router(reports.router, prefix="/api/v1")
app.include_router(ai_analysis.router, prefix="/api/v1")
app.include_router(dashboard.router, prefix="/api/v1")
app.include_router(admin.router, prefix="/api/v1")
app.include_router(helpdesk.router, prefix="/api/v1")

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error("uncaught_exception", exc=str(exc), path=request.url.path)
    return JSONResponse(
        status_code=500,
        content={"detail": "An unexpected error occurred. Please try again later."},
    )

@app.on_event("startup")
async def startup_event():
    setup_logging()
    logger.info("application_started")
    # Add health check or initialization logic if needed

@app.on_event("shutdown")
async def shutdown_event():
    await engine.dispose()
    logger.info("application_shutdown")

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

```python
# backend/app/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import relationship
from app.core.database import Base
import pyotp
import secrets
from datetime import datetime, timezone, timedelta
import structlog

logger = structlog.get_logger()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String, nullable=True)
    hashed_password = Column(String, nullable=False)
    role = Column(String, default="viewer", nullable=False)
    is_active = Column(Boolean, default=True)
    mfa_enabled = Column(Boolean, default=False)
    mfa_secret = Column(String, nullable=True)
    api_key = Column(String, unique=True, nullable=True)
    last_login = Column(DateTime(timezone=True), nullable=True)
    failed_login_attempts = Column(Integer, default=0)
    lockout_until = Column(DateTime(timezone=True), nullable=True)
    sessions = relationship("UserSession", back_populates="user", cascade="all, delete-orphan")
    audit_logs = relationship("UserAuditLog", back_populates="user", cascade="all, delete-orphan")
    tickets = relationship("Ticket", back_populates="user", cascade="all, delete-orphan")

    async def set_password(self, password: str, db: AsyncSession):
        from app.utils.encryption import hash_password
        self.hashed_password = hash_password(password)
        db.add(self)
        await db.commit()
        logger.info("password_set", user_id=self.id)

    def verify_password(self, password: str) -> bool:
        from app.utils.encryption import verify_password
        return verify_password(password, self.hashed_password)

    def generate_api_key(self) -> str:
        self.api_key = secrets.token_urlsafe(32)
        logger.info("api_key_generated", user_id=self.id)
        return self.api_key

    def enable_mfa(self) -> str:
        self.mfa_secret = pyotp.random_base32()
        self.mfa_enabled = True
        logger.info("mfa_enabled", user_id=self.id)
        return self.mfa_secret

    def verify_totp(self, token: str) -> bool:
        if not self.mfa_enabled or not self.mfa_secret:
            return False
        totp = pyotp.TOTP(self.mfa_secret)
        return totp.verify(token)

    def generate_backup_codes(self) -> list:
        codes = [secrets.token_hex(4) for _ in range(10)]
        logger.info("backup_codes_generated", user_id=self.id)
        return codes

    async def record_login_attempt(self, success: bool, ip_address: str, db: AsyncSession):
        from app.models.audit_log import UserAuditLog
        if not success:
            self.failed_login_attempts += 1
            if self.failed_login_attempts >= 5:
                self.lockout_until = datetime.now(timezone.utc) + timedelta(minutes=15)
                logger.warning("user_locked_out", user_id=self.id, ip_address=ip_address)
        else:
            self.failed_login_attempts = 0
            self.lockout_until = None
            self.last_login = datetime.now(timezone.utc)
            logger.info("login_successful", user_id=self.id, ip_address=ip_address)
        audit_log = UserAuditLog(user_id=self.id, action="login_attempt", success=success, ip_address=ip_address)
        db.add(self)
        db.add(audit_log)
        await db.commit()

    def is_locked(self) -> bool:
        if self.lockout_until and self.lockout_until > datetime.now(timezone.utc):
            return True
        return False

    async def update_activity(self, db: AsyncSession):
        self.last_login = datetime.now(timezone.utc)
        db.add(self)
        await db.commit()
        logger.info("activity_updated", user_id=self.id)
```

```python
# backend/app/models/scan.py
from sqlalchemy import Column, Integer, String, DateTime, JSON, ForeignKey
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import relationship
from app.core.database import Base
from datetime import datetime, timezone
import structlog

logger = structlog.get_logger()

class Scan(Base):
    __tablename__ = "scans"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    target = Column(String, nullable=False, index=True)
    scan_type = Column(String, nullable=False)
    status = Column(String, default="pending")
    start_time = Column(DateTime(timezone=True), nullable=True)
    end_time = Column(DateTime(timezone=True), nullable=True)
    total_findings = Column(Integer, default=0)
    critical_findings = Column(Integer, default=0)
    high_findings = Column(Integer, default=0)
    medium_findings = Column(Integer, default=0)
    low_findings = Column(Integer, default=0)
    info_findings = Column(Integer, default=0)
    configuration = Column(JSON, nullable=True)
    vulnerabilities = relationship("Vulnerability", back_populates="scan", cascade="all, delete-orphan")

    async def start_scan(self, db: AsyncSession):
        self.status = "running"
        self.start_time = datetime.now(timezone.utc)
        db.add(self)
        await db.commit()
        logger.info("scan_started", scan_id=self.id, target=self.target)

    async def complete_scan(self, db: AsyncSession):
        self.status = "completed"
        self.end_time = datetime.now(timezone.utc)
        db.add(self)
        await db.commit()
        logger.info("scan_completed", scan_id=self.id, target=self.target)
```

```python
# backend/app/models/vulnerability.py
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey, JSON
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import relationship
from app.core.database import Base
from datetime import datetime, timezone
from app.core.config import settings
import structlog

logger = structlog.get_logger()

class Vulnerability(Base):
    __tablename__ = "vulnerabilities"

    id = Column(Integer, primary_key=True, index=True)
    scan_id = Column(Integer, ForeignKey("scans.id", ondelete="CASCADE"), nullable=False)
    title = Column(String, nullable=False)
    severity = Column(String, nullable=True)
    cvss_score = Column(Float, nullable=True)
    cve_id = Column(String, nullable=True, index=True)
    cwe_id = Column(String, nullable=True)
    description = Column(String, nullable=True)
    affected_component = Column(String, nullable=True)
    port = Column(Integer, nullable=True)
    service = Column(String, nullable=True)
    remediation = Column(String, nullable=True)
    evidence = Column(JSON, nullable=True)
    detected_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    risk_score = Column(Float, nullable=True)
    scan = relationship("Scan", back_populates="vulnerabilities")

    def calculate_risk_score(self):
        if self.cvss_score is not None:
            severity_config = settings.SEVERITY_LEVELS.get(self.severity.upper() if self.severity else "INFO", settings.SEVERITY_LEVELS["INFO"])
            self.risk_score = self.cvss_score * (severity_config["score"] / 10)
        else:
            self.risk_score = 1.0
        logger.debug("risk_score_calculated", vulnerability_id=self.id, risk_score=self.risk_score)

    def update_severity_from_cvss(self):
        if self.cvss_score is not None:
            if self.cvss_score >= 9.0:
                self.severity = "CRITICAL"
            elif self.cvss_score >= 7.0:
                self.severity = "HIGH"
            elif self.cvss_score >= 4.0:
                self.severity = "MEDIUM"
            elif self.cvss_score >= 0.1:
                self.severity = "LOW"
            else:
                self.severity = "INFO"
            logger.debug("severity_updated", vulnerability_id=self.id, severity=self.severity)
```

```python
# backend/app/models/alert.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, JSON
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import Base
from datetime import datetime, timezone
import structlog

logger = structlog.get_logger()

class Alert(Base):
    __tablename__ = "alerts"

    id = Column(Integer, primary_key=True, index=True)
    scan_id = Column(Integer, ForeignKey("scans.id", ondelete="SET NULL"), nullable=True)
    vulnerability_id = Column(Integer, ForeignKey("vulnerabilities.id", ondelete="SET NULL"), nullable=True)
    severity = Column(String, nullable=False)
    message = Column(String, nullable=False)
    status = Column(String, default="open")
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    resolved_at = Column(DateTime(timezone=True), nullable=True)
    details = Column(JSON, nullable=True)

    async def resolve(self, db: AsyncSession):
        self.status = "resolved"
        self.resolved_at = datetime.now(timezone.utc)
        db.add(self)
        await db.commit()
        logger.info("alert_resolved", alert_id=self.id)
```

```python
# backend/app/models/ai_model.py
from sqlalchemy import Column, Integer, String, DateTime, JSON
from app.core.database import Base
from datetime import datetime, timezone
import structlog

logger = structlog.get_logger()

class AIModel(Base):
    __tablename__ = "ai_models"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    provider = Column(String, nullable=False)
    configuration = Column(JSON, nullable=False)
    last_used = Column(DateTime(timezone=True), nullable=True)
    requests = relationship("AIRequest", back_populates="model", cascade="all, delete-orphan")

    def update_last_used(self):
        self.last_used = datetime.now(timezone.utc)
        logger.debug("ai_model_used", model_id=self.id, name=self.name)
```

```python
# backend/app/models/ticket.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import Base
from datetime import datetime, timezone
import structlog

logger = structlog.get_logger()

class Ticket(Base):
    __tablename__ = "tickets"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    subject = Column(String, nullable=False)
    details = Column(String, nullable=False)
    status = Column(String, default="open")
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc), nullable=True)
    user = relationship("User", back_populates="tickets")

    async def update_status(self, status: str, db: AsyncSession):
        self.status = status
        self.updated_at = datetime.now(timezone.utc)
        db.add(self)
        await db.commit()
        logger.info("ticket_status_updated", ticket_id=self.id, status=status)
```

```python
# backend/app/models/audit_log.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey
from app.core.database import Base
from datetime import datetime, timezone
import structlog

logger = structlog.get_logger()

class UserAuditLog(Base):
    __tablename__ = "user_audit_logs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    action = Column(String, nullable=False)
    success = Column(Boolean, nullable=False)
    ip_address = Column(String, nullable=True)
    timestamp = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    user = relationship("User", back_populates="audit_logs")
```

```python
# backend/app/models/user_session.py
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from app.core.database import Base
from datetime import datetime, timezone
import structlog

logger = structlog.get_logger()

class UserSession(Base):
    __tablename__ = "user_sessions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    token = Column(String, nullable=False, unique=True)
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    expires_at = Column(DateTime(timezone=True), nullable=False)
    user = relationship("User", back_populates="sessions")
```

```python
# backend/app/api/v1/endpoints/auth.py
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.database import get_db
from app.core.security import create_access_token, create_refresh_token, get_current_user
from app.models.user import User
from app.models.user_session import UserSession
from app.schemas.user import UserCreate, UserResponse, TokenResponse, PasswordResetRequest, PasswordResetConfirm
from app.utils.email import EmailService
from datetime import datetime, timezone, timedelta
import structlog
from jose import jwt

logger = structlog.get_logger()
router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def register(user_data: UserCreate, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User).filter((User.email == user_data.email) | (User.username == user_data.username)))
    existing_user = result.scalar_one_or_none()
    if existing_user:
        logger.warning("registration_failed_duplicate", email=user_data.email, username=user_data.username)
        raise HTTPException(status_code=400, detail="User with this email or username already exists")
    
    user = User(**user_data.dict(exclude={"password"}))
    await user.set_password(user_data.password, db)
    user.generate_api_key()
    db.add(user)
    await db.commit()
    await db.refresh(user)
    logger.info("user_registered", user_id=user.id, username=user.username)
    return UserResponse.from_orm(user)

@router.post("/login", response_model=TokenResponse)
async def login(
    request: Request,
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    ip_address = request.client.host
    result = await db.execute(select(User).filter(User.username == form_data.username))
    user = result.scalar_one_or_none()
    
    if not user or not user.verify_password(form_data.password) or not user.is_active:
        if user:
            await user.record_login_attempt(False, ip_address, db)
        logger.warning("login_failed_invalid_credentials", username=form_data.username, ip_address=ip_address)
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    if user.is_locked():
        logger.warning("login_failed_locked", user_id=user.id, ip_address=ip_address)
        raise HTTPException(status_code=403, detail="Account is temporarily locked")

    if user.mfa_enabled and not form_data.mfaToken:
        await user.record_login_attempt(True, ip_address, db)
        logger.info("mfa_required", user_id=user.id, ip_address=ip_address)
        return {"status": 206, "detail": "MFA token required"}

    if user.mfa_enabled and not user.verify_totp(form_data.mfaToken):
        await user.record_login_attempt(False, ip_address, db)
        logger.warning("login_failed_invalid_mfa", user_id=user.id, ip_address=ip_address)
        raise HTTPException(status_code=401, detail="Invalid MFA token")

    await user.record_login_attempt(True, ip_address, db)
    access_token = create_access_token({"sub": str(user.id)})
    refresh_token = create_refresh_token({"sub": str(user.id)})
    session = UserSession(
        user_id=user.id,
        token=access_token,
        expires_at=datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    db.add(session)
    await db.commit()
    logger.info("login_successful", user_id=user.id, ip_address=ip_address)
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        user=UserResponse.from_orm(user)
    )

@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(request: Request, db: AsyncSession = Depends(get_db)):
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Refresh token required")
    
    token = auth_header.split(" ")[1]
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid refresh token")
    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    result = await db.execute(select(User).filter(User.id == user_id))
    user = result.scalar_one_or_none()
    if not user or not user.is_active:
        logger.warning("refresh_failed_invalid_user", user_id=user_id)
        raise HTTPException(status_code=401, detail="User not found or inactive")

    access_token = create_access_token({"sub": str(user.id)})
    refresh_token = create_refresh_token({"sub": str(user.id)})
    session = UserSession(
        user_id=user.id,
        token=access_token,
        expires_at=datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    db.add(session)
    await db.commit()
    logger.info("token_refreshed", user_id=user.id)
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        user=UserResponse.from_orm(user)
    )

@router.post("/reset-password-request")
async def reset_password_request(
    reset_data: PasswordResetRequest,
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(User).filter(User.email == reset_data.email))
    user = result.scalar_one_or_none()
    if not user or not user.is_active:
        logger.warning("password_reset_request_failed", email=reset_data.email)
        raise HTTPException(status_code=404, detail="Email not found")

    reset_token = create_access_token({"sub": str(user.id), "type": "reset"}, timedelta(hours=1))
    email_service = EmailService()
    reset_url = f"https://jadeultimate.com/reset-password?token={reset_token}"
    email_service.send_email(
        to_email=user.email,
        subject="Password Reset Request",
        body=f"Click here to reset your password: {reset_url}\nThis link expires in 1 hour."
    )
    logger.info("password_reset_email_sent", user_id=user.id, email=user.email)
    return {"message": "Password reset link sent"}

@router.post("/reset-password-confirm")
async def reset_password_confirm(
    reset_data: PasswordResetConfirm,
    db: AsyncSession = Depends(get_db)
):
    try:
        payload = jwt.decode(reset_data.token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        if payload.get("type") != "reset":
            raise HTTPException(status_code=400, detail="Invalid token type")
        user_id = payload.get("sub")
    except jwt.JWTError:
        logger.warning("password_reset_confirm_failed_invalid_token")
        raise HTTPException(status_code=400, detail="Invalid or expired token")

    result = await db.execute(select(User).filter(User.id == user_id))
    user = result.scalar_one_or_none()
    if not user or not user.is_active:
        logger.warning("password_reset_confirm_failed_user_not_found", user_id=user_id)
        raise HTTPException(status_code=404, detail="User not found")

    await user.set_password(reset_data.new_password, db)
    logger.info("password_reset_successful", user_id=user.id)
    return {"message": "Password reset successful"}

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    logger.info("user_info_accessed", user_id=current_user.id)
    return UserResponse.from_orm(current_user)

@router.put("/settings")
async def update_settings(
    settings_data: dict,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    if "mfa_enabled" in settings_data:
        current_user.mfa_enabled = settings_data["mfa_enabled"]
        if current_user.mfa_enabled and not current_user.mfa_secret:
            current_user.enable_mfa()
    db.add(current_user)
    await db.commit()
    logger.info("settings_updated", user_id=current_user.id)
    return {"message": "Settings updated"}
```

```python
# backend/app/api/v1/endpoints/scans.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.database import get_db
from app.core.security import get_current_user
from app.models.scan import Scan
from app.models.user import User
from app.schemas.scan import ScanCreate, ScanResponse
import structlog

logger = structlog.get_logger()
router = APIRouter(prefix="/scans", tags=["scans"])

@router.post("/", response_model=ScanResponse, status_code=status.HTTP_201_CREATED)
async def create_scan(
    scan_data: ScanCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    if not scan_data.target or not scan_data.scan_type:
        logger.warning("scan_creation_failed_invalid_input", user_id=current_user.id)
        raise HTTPException(status_code=400, detail="Target and scan type are required")
    
    scan = Scan(
        user_id=current_user.id,
        target=scan_data.target,
        scan_type=scan_data.scan_type,
        configuration=scan_data.configuration
    )
    db.add(scan)
    await db.commit()
    await db.refresh(scan)
    await scan.start_scan(db)
    logger.info("scan_created", scan_id=scan.id, user_id=current_user.id, target=scan.target)
    return ScanResponse.from_orm(scan)

@router.get("/", response_model=list[ScanResponse])
async def list_scans(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Scan).filter(Scan.user_id == current_user.id))
    scans = result.scalars().all()
    logger.info("scans_listed", user_id=current_user.id, count=len(scans))
    return [ScanResponse.from_orm(scan) for scan in scans]

@router.get("/{scan_id}", response_model=ScanResponse)
async def get_scan(
    scan_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Scan).filter(Scan.id == scan_id, Scan.user_id == current_user.id))
    scan = result.scalar_one_or_none()
    if not scan:
        logger.warning("scan_not_found", scan_id=scan_id, user_id=current_user.id)
        raise HTTPException(status_code=404, detail="Scan not found")
    logger.info("scan_retrieved", scan_id=scan_id, user_id=current_user.id)
    return ScanResponse.from_orm(scan)
```

```python
# backend/app/api/v1/endpoints/vulnerabilities.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.database import get_db
from app.core.security import get_current_user
from app.models.vulnerability import Vulnerability
from app.models.user import User
from app.schemas.vulnerability import VulnerabilityResponse
import structlog

logger = structlog.get_logger()
router = APIRouter(prefix="/vulnerabilities", tags=["vulnerabilities"])

@router.get("/", response_model=list[VulnerabilityResponse])
async def list_vulnerabilities(
    scan_id: int = Query(None, description="Filter by scan ID"),
    severity: str = Query(None, description="Filter by severity"),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    query = select(Vulnerability).join(Scan).filter(Scan.user_id == current_user.id)
    if scan_id:
        query = query.filter(Vulnerability.scan_id == scan_id)
    if severity:
        query = query.filter(Vulnerability.severity == severity.upper())
    
    result = await db.execute(query)
    vulnerabilities = result.scalars().all()
    logger.info("vulnerabilities_listed", user_id=current_user.id, count=len(vulnerabilities))
    return [VulnerabilityResponse.from_orm(vuln) for vuln in vulnerabilities]
```

```python
# backend/app/api/v1/endpoints/reports.py
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.database import get_db
from app.core.security import get_current_user
from app.models.scan import Scan
from app.models.user import User
from app.services.report_service import ReportService
import io
import structlog

logger = structlog.get_logger()
router = APIRouter(prefix="/reports", tags=["reports"])

@router.get("/", response_model=list[dict])
async def list_reports(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Scan).filter(Scan.user_id == current_user.id))
    scans = result.scalars().all()
    reports = [{"scan_id": scan.id, "target": scan.target} for scan in scans]
    logger.info("reports_listed", user_id=current_user.id, count=len(reports))
    return reports

@router.get("/{scan_id}")
async def generate_report(
    scan_id: int,
    report_type: str = Query("executive", enum=["executive", "technical"]),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(Scan).filter(Scan.id == scan_id, Scan.user_id == current_user.id))
    scan = result.scalar_one_or_none()
    if not scan:
        logger.warning("report_generation_failed_scan_not_found", scan_id=scan_id, user_id=current_user.id)
        raise HTTPException(status_code=404, detail="Scan not found")

    report_service = ReportService()
    scan_data = scan.__dict__
    scan_data["vulnerabilities"] = [vuln.__dict__ for vuln in scan.vulnerabilities]
    pdf_content = await report_service.generate_security_report(scan_data, report_type)
    
    logger.info("report_generated", scan_id=scan_id, user_id=current_user.id, report_type=report_type)
    return StreamingResponse(
        io.BytesIO(pdf_content),
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=report_{scan_id}_{report_type}.pdf"}
    )
```

```python
# backend/app/api/v1/endpoints/ai_analysis.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.services.ai_service import AIService
from app.schemas.ai import AIRequestCreate, AIResponse
import structlog

logger = structlog.get_logger()
router = APIRouter(prefix="/ai", tags=["ai_analysis"])

@router.post("/analyze", response_model=AIResponse)
async def analyze_vulnerability(
    request: AIRequestCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    ai_service = AIService(db)
    try:
        analysis = await ai_service.analyze_vulnerability(request.dict(exclude_unset=True))
        logger.info("ai_analysis_completed", user_id=current_user.id, vulnerability_id=request.id)
        return AIResponse(**analysis)
    except Exception as e:
        logger.error("ai_analysis_failed", user_id=current_user.id, error=str(e))
        raise HTTPException(status_code=500, detail="AI analysis failed")
```

```python
# backend/app/api/v1/endpoints/dashboard.py
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from app.core.database import get_db
from app.core.security import get_current_user
from app.models.scan import Scan
from app.models.vulnerability import Vulnerability
from app.models.user import User
from app.schemas.dashboard import DashboardStats
import structlog

logger = structlog.get_logger()
router = APIRouter(prefix="/dashboard", tags=["dashboard"])

@router.get("/stats", response_model=DashboardStats)
async def get_dashboard_stats(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    total_scans_query = select(func.count(Scan.id)).filter(Scan.user_id == current_user.id)
    active_scans_query = select(func.count(Scan.id)).filter(Scan.user_id == current_user.id, Scan.status == "running")
    vuln_query = select(Vulnerability.severity, func.count(Vulnerability.id)).join(Scan).filter(Scan.user_id == current_user.id).group_by(Vulnerability.severity)

    total_scans = (await db.execute(total_scans_query)).scalar()
    active_scans = (await db.execute(active_scans_query)).scalar()
    vuln_result = await db.execute(vuln_query)
    vulnerabilities = {row[0]: row[1] for row in vuln_result.fetchall() if row[0]}

    # Placeholder for threat intelligence; integrate with external service if needed
    threats = [{"threat_actor": "Example Actor", "risk_level": "High"}] if total_scans > 0 else []

    stats = DashboardStats(
        total_scans=total_scans or 0,
        active_scans=active_scans or 0,
        vulnerabilities=vulnerabilities,
        threats=threats
    )
    logger.info("dashboard_stats_retrieved", user_id=current_user.id)
    return stats
```

```python
# backend/app/api/v1/endpoints/admin.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from app.core.database import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.models.audit_log import UserAuditLog
from app.schemas.admin import AdminStats, AuditLogResponse
import structlog

logger = structlog.get_logger()
router = APIRouter(prefix="/admin", tags=["admin"])

@router.get("/stats", response_model=AdminStats)
async def get_admin_stats(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    if current_user.role != "admin":
        logger.warning("admin_stats_access_denied", user_id=current_user.id)
        raise HTTPException(status_code=403, detail="Admin access required")

    user_count = (await db.execute(select(func.count(User.id)))).scalar()
    audit_log_count = (await db.execute(select(func.count(UserAuditLog.id)))).scalar()
    
    stats = AdminStats(user_count=user_count, audit_log_count=audit_log_count)
    logger.info("admin_stats_retrieved", user_id=current_user.id)
    return stats

@router.get("/audit-logs", response_model=list[AuditLogResponse])
async def get_audit_logs(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    if current_user.role != "admin":
        logger.warning("audit_logs_access_denied", user_id=current_user.id)
        raise HTTPException(status_code=403, detail="Admin access required")

    result = await db.execute(select(UserAuditLog).order_by(UserAuditLog.timestamp.desc()).limit(100))
    logs = result.scalars().all()
    logger.info("audit_logs_retrieved", user_id=current_user.id, count=len(logs))
    return [AuditLogResponse.from_orm(log) for log in logs]
```

```python
# backend/app/api/v1/endpoints/helpdesk.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.core.security import get_current_user
from app.models.ticket import Ticket
from app.models.user import User
from app.schemas.ticket import TicketCreate, TicketResponse
import structlog

logger = structlog.get_logger()
router = APIRouter(prefix="/helpdesk", tags=["helpdesk"])

@router.post("/ticket", response_model=TicketResponse, status_code=201)
async def submit_ticket(
    ticket_data: TicketCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    ticket = Ticket(
        user_id=current_user.id,
        subject=ticket_data.subject,
        details=ticket_data.details
    )
    db.add(ticket)
    await db.commit()
    await db.refresh(ticket)
    logger.info("ticket_submitted", ticket_id=ticket.id, user_id=current_user.id)
    return TicketResponse.from_orm(ticket)

@router.get("/tickets", response_model=list[TicketResponse])
async def list_tickets(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    if current_user.role != "admin":
        result = await db.execute(select(Ticket).filter(Ticket.user_id == current_user.id))
    else:
        result = await db.execute(select(Ticket))
    tickets = result.scalars().all()
    logger.info("tickets_listed", user_id=current_user.id, count=len(tickets))
    return [TicketResponse.from_orm(ticket) for ticket in tickets]
```

```python
# backend/app/services/ai_service.py
from typing import Dict, List
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.config import settings
from app.models.ai_model import AIModel
from app.models.ai_request import AIRequest
import aiohttp
import structlog
from datetime import datetime

logger = structlog.get_logger()

class AIService:
    def __init__(self, db: AsyncSession):
        self.db = db

    async def analyze_vulnerability(self, vuln_data: Dict) -> Dict:
        model_name = "gpt-4"  # Default model; can be made configurable
        result = await db.execute(select(AIModel).filter(AIModel.name == model_name))
        ai_model = result.scalar_one_or_none()
        if not ai_model:
            logger.warning("ai_model_not_found", model_name=model_name)
            ai_model = AIModel(name=model_name, provider="openai", configuration=settings.AI_MODELS[model_name])
            db.add(ai_model)
            await db.commit()

        config = ai_model.configuration
        headers = {"Authorization": f"Bearer {settings.OPENAI_API_KEY}", "Content-Type": "application/json"}
        payload = {
            "model": config["model"],
            "prompt": self._build_prompt(vuln_data),
            "temperature": config["temperature"],
            "max_tokens": 500,
        }

        async with aiohttp.ClientSession() as session:
            async with session.post("https://api.openai.com/v1/completions", json=payload, headers=headers) as response:
                if response.status != 200:
                    logger.error("ai_request_failed", status=response.status, model_name=model_name)
                    raise Exception("AI service unavailable")
                result = await response.json()
                response_text = result["choices"][0]["text"].strip()

        ai_model.update_last_used()
        ai_request = AIRequest(model_id=ai_model.id, request_data=vuln_data, response_data=response_text)
        db.add(ai_request)
        await db.commit()

        logger.info("ai_analysis_performed", model_name=model_name, vuln_id=vuln_data.get("id"))
        return self._parse_response(response_text, model_name)

    def _build_prompt(self, vuln_data: Dict) -> str:
        return f"""
        Analyze this vulnerability:
        Title: {vuln_data.get("title", "N/A")}
        Severity: {vuln_data.get("severity", "N/A")}
        CVSS Score: {vuln_data.get("cvss_score", "N/A")}
        CVE ID: {vuln_data.get("cve_id", "N/A")}
        Description: {vuln_data.get("description", "N/A")}
        Affected Component: {vuln_data.get("affected_component", "N/A")}

        Provide:
        - Risk Assessment
        - Threat Context
        - Remediation Suggestions
        - Business Impact
        - Exploitability
        """

    def _parse_response(self, response: str, model_used: str) -> Dict:
        return {
            "risk_assessment": self._extract_section(response, "Risk Assessment:"),
            "threat_context": self._extract_section(response, "Threat Context:"),
            "remediation_suggestions": self._extract_section(response, "Remediation Suggestions:"),
            "business_impact": self._extract_section(response, "Business Impact:"),
            "exploitability": self._extract_section(response, "Exploitability:"),
            "ai_confidence": 0.9,  # Placeholder; implement actual confidence scoring
            "model_used": model_used,
            "analyzed_at": datetime.utcnow().isoformat(),
        }

    def _extract_section(self, response: str, section: str) -> str:
        try:
            start = response.index(section) + len(section)
            end = response.index("\n", start) if "\n" in response[start:] else len(response)
            return response[start:end].strip()
        except ValueError:
            return "Not available"
```

```python
# backend/app/services/report_service.py
import pdfkit
from datetime import datetime
from jinja2 import Environment, FileSystemLoader
import structlog
from app.core.config import settings

logger = structlog.get_logger()

class ReportService:
    def __init__(self):
        self.env = Environment(loader=FileSystemLoader("templates"))

    async def generate_security_report(self, scan_data: dict, report_type: str) -> bytes:
        try:
            template_name = "executive_report.html" if report_type == "executive" else "technical_report.html"
            template = self.env.get_template(template_name)
            html_content = template.render(
                scan=scan_data,
                date=datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC"),
                company_name=settings.PROJECT_NAME,
                report_type=report_type.capitalize()
            )
            pdf_content = pdfkit.from_string(
                html_content,
                False,
                configuration=pdfkit.configuration(wkhtmltopdf=settings.WKHTMLTOPDF_PATH),
                options={"quiet": ""}
            )
            logger.info("report_pdf_generated", scan_id=scan_data.get("id"), report_type=report_type)
            return pdf_content
        except Exception as e:
            logger.error("report_generation_failed", error=str(e), scan_id=scan_data.get("id"))
            raise
```

```python
# backend/app/utils/email.py
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from app.core.config import settings
import structlog
import asyncio

logger = structlog.get_logger()

class EmailService:
    async def send_email(self, to_email: str, subject: str, body: str):
        loop = asyncio.get_event_loop()
        try:
            msg = MIMEMultipart()
            msg['From'] = settings.EMAIL_FROM
            msg['To'] = to_email
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))

            await loop.run_in_executor(None, self._send_smtp, msg)
            logger.info("email_sent", to_email=to_email, subject=subject)
        except Exception as e:
            logger.error("email_send_failed", error=str(e), to_email=to_email)
            raise

    def _send_smtp(self, msg: MIMEMultipart):
        with smtplib.SMTP(settings.SMTP_SERVER, settings.SMTP_PORT) as server:
            server.starttls()
            server.login(settings.SMTP_USERNAME, settings.SMTP_PASSWORD)
            server.send_message(msg)
```

```python
# backend/app/utils/encryption.py
from passlib.context import CryptContext
from cryptography.fernet import Fernet
from app.core.config import settings
import structlog

logger = structlog.get_logger()

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
cipher_suite = Fernet(settings.SECRET_KEY.encode())

def hash_password(password: str) -> str:
    hashed = pwd_context.hash(password)
    logger.debug("password_hashed")
    return hashed

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def encrypt_data(data: str) -> str:
    encrypted = cipher_suite.encrypt(data.encode()).decode()
    logger.debug("data_encrypted")
    return encrypted

def decrypt_data(encrypted_data: str) -> str:
    try:
        decrypted = cipher_suite.decrypt(encrypted_data.encode()).decode()
        logger.debug("data_decrypted")
        return decrypted
    except Exception as e:
        logger.error("decryption_failed", error=str(e))
        raise
```

```python
# backend/app/utils/logger.py
import structlog
import logging
from app.core.config import settings

def setup_logging():
    structlog.configure(
        processors=[
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.stdlib.add_log_level,
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.JSONRenderer()
        ],
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )
    logging.basicConfig(
        format="%(message)s",
        handlers=[
            logging.FileHandler(settings.LOG_FILE),
            logging.StreamHandler()
        ],
        level=logging.INFO
    )
```

```python
# backend/app/core/config.py
from pydantic import BaseSettings
from typing import Dict, Any

class Settings(BaseSettings):
    PROJECT_NAME: str = "JADE Ultimate"
    SECRET_KEY: str = "your-secret-key-securely-generated"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    DATABASE_URL: str = "postgresql+asyncpg://user:password@localhost:5432/jade_db"
    SMTP_SERVER: str = "smtp.gmail.com"
    SMTP_PORT: int = 587
    SMTP_USERNAME: str = "your-email@gmail.com"
    SMTP_PASSWORD: str = "your-app-specific-password"
    EMAIL_FROM: str = "support@jadeultimate.com"
    WKHTMLTOPDF_PATH: str = "/usr/bin/wkhtmltopdf"
    OPENAI_API_KEY: str = "your-openai-api-key"
    ANTHROPIC_API_KEY: str = "your-anthropic-api-key"
    GEMINI_API_KEY: str = "your-gemini-api-key"
    TOGETHER_AI_API_KEY: str = "your-together-ai-api-key"
    LOG_FILE: str = "logs/app.log"
    SEVERITY_LEVELS: Dict[str, Any] = {
        "CRITICAL": {"score": 10, "color": "#dc3545"},
        "HIGH": {"score": 8, "color": "#fd7e14"},
        "MEDIUM": {"score": 6, "color": "#ffc107"},
        "LOW": {"score": 4, "color": "#28a745"},
        "INFO": {"score": 2, "color": "#17a2b8"}
    }
    AI_MODELS: Dict[str, Any] = {
        "gpt-4": {"provider": "openai", "model": "gpt-4", "temperature": 0.1},
        "gpt-4-turbo": {"provider": "openai", "model": "gpt-4-turbo", "temperature": 0.1},
        "claude-3-opus": {"provider": "anthropic", "model": "claude-3-opus-20240229", "temperature": 0.1},
        "gemini-pro": {"provider": "google", "model": "gemini-pro", "temperature": 0.1},
        "mixtral-8x7b": {"provider": "together", "model": "mistralai/Mixtral-8x7B-Instruct-v0.1", "temperature": 0.1}
    }

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()
```

```python
# backend/app/core/security.py
from datetime import datetime, timedelta, timezone
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.user import User
from app.core.database import get_db
from app.core.config import settings
import structlog

logger = structlog.get_logger()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire.timestamp()})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    logger.debug("access_token_created", sub=data.get("sub"))
    return encoded_jwt

def create_refresh_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire.timestamp()})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    logger.debug("refresh_token_created", sub=data.get("sub"))
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        if not user_id:
            logger.warning("token_validation_failed_no_sub")
            raise credentials_exception
    except JWTError as e:
        logger.warning("token_validation_failed", error=str(e))
        raise credentials_exception
    
    result = await db.execute(select(User).filter(User.id == int(user_id)))
    user = result.scalar_one_or_none()
    if not user or not user.is_active:
        logger.warning("user_not_found_or_inactive", user_id=user_id)
        raise credentials_exception
    
    await user.update_activity(db)
    return user
```

```python
# backend/app/core/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings
from sqlalchemy.ext.declarative import declarative_base
import structlog

logger = structlog.get_logger()

Base = declarative_base()

engine = create_async_engine(settings.DATABASE_URL, echo=False, pool_pre_ping=True)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_db():
    async with async_session() as session:
        try:
            yield session
        except Exception as e:
            logger.error("database_session_error", error=str(e))
            await session.rollback()
            raise
        finally:
            await session.close()
```

```python
# backend/app/schemas/user.py
from pydantic import BaseModel, EmailStr, Field
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    full_name: Optional[str] = Field(None, max_length=100)

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, regex="^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).+$")

class UserResponse(UserBase):
    id: int
    role: str
    is_active: bool
    mfa_enabled: bool
    last_login: Optional[datetime] = None

    class Config:
        orm_mode = True

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str
    expires_in: int
    user: UserResponse

class PasswordResetRequest(BaseModel):
    email: EmailStr

class PasswordResetConfirm(BaseModel):
    token: str
    new_password: str = Field(..., min_length=8, regex="^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).+$")
```

```python
# backend/app/schemas/scan.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict

class ScanBase(BaseModel):
    target: str = Field(..., max_length=255)
    scan_type: str = Field(..., max_length=50)
    configuration: Optional[Dict] = None

class ScanCreate(ScanBase):
    pass

class ScanResponse(ScanBase):
    id: int
    user_id: int
    status: str
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    total_findings: int
    critical_findings: int
    high_findings: int
    medium_findings: int
    low_findings: int
    info_findings: int

    class Config:
        orm_mode = True
```

```python
# backend/app/schemas/vulnerability.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict

class VulnerabilityBase(BaseModel):
    title: str = Field(..., max_length=255)
    severity: Optional[str] = None
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = Field(None, max_length=20)
    cwe_id: Optional[str] = Field(None, max_length=20)
    description: Optional[str] = None
    affected_component: Optional[str] = Field(None, max_length=255)
    port: Optional[int] = None
    service: Optional[str] = Field(None, max_length=50)
    remediation: Optional[str] = None
    evidence: Optional[Dict] = None

class VulnerabilityResponse(VulnerabilityBase):
    id: int
    scan_id: int
    detected_at: datetime
    risk_score: Optional[float] = None

    class Config:
        orm_mode = True
```

```python
# backend/app/schemas/ai.py
from pydantic import BaseModel
from typing import Dict, Optional

class AIRequestCreate(BaseModel):
    id: Optional[int] = None
    title: Optional[str] = Field(None, max_length=255)
    severity: Optional[str] = None
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = Field(None, max_length=20)
    description: Optional[str] = None
    affected_component: Optional[str] = Field(None, max_length=255)

class AIResponse(BaseModel):
    risk_assessment: str
    threat_context: str
    remediation_suggestions: str
    business_impact: str
    exploitability: str
    ai_confidence: float
    model_used: str
    analyzed_at: str
```

```python
# backend/app/schemas/dashboard.py
from pydantic import BaseModel
from typing import Dict, List

class DashboardStats(BaseModel):
    total_scans: int
    active_scans: int
    vulnerabilities: Dict[str, int]
    threats: List[Dict]
```

```python
# backend/app/schemas/admin.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class AdminStats(BaseModel):
    user_count: int
    audit_log_count: int

class AuditLogResponse(BaseModel):
    id: int
    user_id: int
    action: str
    success: bool
    ip_address: Optional[str] = None
    timestamp: datetime

    class Config:
        orm_mode = True
```

```python
# backend/app/schemas/ticket.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class TicketBase(BaseModel):
    subject: str = Field(..., min_length=5, max_length=255)
    details: str = Field(..., min_length=10)

class TicketCreate(TicketBase):
    pass

class TicketResponse(TicketBase):
    id: int
    user_id: int
    status: str
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        orm_mode = True
```

```python
# backend/templates/executive_report.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ report_type }} Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .section { margin: 20px 0; }
        .table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .table th, .table td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        h1, h2 { color: #333; }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ report_type }} Report</h1>
        <p>{{ company_name }}</p>
        <p>Date: {{ date }}</p>
    </div>
    <div class="section">
        <h2>Scan Details</h2>
        <p><strong>Target:</strong> {{ scan.target }}</p>
        <p><strong>Scan Type:</strong> {{ scan.scan_type }}</p>
        <p><strong>Total Findings:</strong> {{ scan.total_findings }}</p>
        <p><strong>Critical Findings:</strong> {{ scan.critical_findings }}</p>
    </div>
    <div class="section">
        <h2>Executive Summary</h2>
        <p>This report provides a high-level overview of security findings for the scanned target. Critical issues should be addressed immediately to mitigate risks.</p>
    </div>
</body>
</html>
```

```python
# backend/templates/technical_report.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ report_type }} Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .section { margin: 20px 0; }
        .table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .table th, .table td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        h1, h2 { color: #333; }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ report_type }} Report</h1>
        <p>{{ company_name }}</p>
        <p>Date: {{ date }}</p>
    </div>
    <div class="section">
        <h2>Scan Details</h2>
        <p><strong>Target:</strong> {{ scan.target }}</p>
        <p><strong>Scan Type:</strong> {{ scan.scan_type }}</p>
        <p><strong>Total Findings:</strong> {{ scan.total_findings }}</p>
        <p><strong>Critical Findings:</strong> {{ scan.critical_findings }}</p
```html
        <p><strong>High Findings:</strong> {{ scan.high_findings }}</p>
        <p><strong>Medium Findings:</strong> {{ scan.medium_findings }}</p>
        <p><strong>Low Findings:</strong> {{ scan.low_findings }}</p>
        <p><strong>Info Findings:</strong> {{ scan.info_findings }}</p>
    </div>
    <div class="section">
        <h2>Vulnerability Details</h2>
        <table class="table">
            <thead>
                <tr>
                    <th>Title</th>
                    <th>Severity</th>
                    <th>CVSS Score</th>
                    <th>CVE ID</th>
                    <th>Description</th>
                    <th>Remediation</th>
                </tr>
            </thead>
            <tbody>
                {% for vuln in scan.vulnerabilities %}
                <tr>
                    <td>{{ vuln.title }}</td>
                    <td>{{ vuln.severity }}</td>
                    <td>{{ vuln.cvss_score or 'N/A' }}</td>
                    <td>{{ vuln.cve_id or 'N/A' }}</td>
                    <td>{{ vuln.description or 'N/A' }}</td>
                    <td>{{ vuln.remediation or 'N/A' }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</body>
</html>
```

```python
# backend/tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from app.main import app
from app.core.database import Base, get_db
from app.core.config import Settings
import structlog
import asyncio

logger = structlog.get_logger()

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
async def test_engine():
    settings = Settings(DATABASE_URL="sqlite+aiosqlite:///:memory:")
    engine = create_async_engine(settings.DATABASE_URL, echo=False)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield engine
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    await engine.dispose()

@pytest.fixture
async def db_session(test_engine):
    async_session = sessionmaker(test_engine, class_=AsyncSession, expire_on_commit=False)
    async with async_session() as session:
        yield session

@pytest.fixture
def client(db_session):
    async def override_get_db():
        yield db_session
    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as client:
        yield client
    app.dependency_overrides.clear()

@pytest.fixture
async def create_test_user(db_session):
    from app.models.user import User
    user = User(
        username="testuser",
        email="testuser@example.com",
        full_name="Test User",
        hashed_password=hash_password("TestPassword123!"),
        role="viewer",
        is_active=True
    )
    db_session.add(user)
    await db_session.commit()
    await db_session.refresh(user)
    logger.info("test_user_created", user_id=user.id)
    return user
```

```python
# backend/tests/test_auth.py
import pytest
from fastapi import status
from app.models.user import User
from app.utils.encryption import hash_password
import structlog

logger = structlog.get_logger()

@pytest.mark.asyncio
async def test_register_user(client, db_session):
    payload = {
        "username": "newuser",
        "email": "newuser@example.com",
        "full_name": "New User",
        "password": "SecurePass123!"
    }
    response = client.post("/api/v1/auth/register", json=payload)
    assert response.status_code == status.HTTP_201_CREATED
    data = response.json()
    assert data["username"] == payload["username"]
    assert data["email"] == payload["email"]
    
    result = await db_session.execute(select(User).filter(User.username == payload["username"]))
    user = result.scalar_one_or_none()
    assert user is not None
    logger.info("test_register_user_success", username=payload["username"])

@pytest.mark.asyncio
async def test_login_success(client, create_test_user):
    payload = {
        "username": "testuser",
        "password": "TestPassword123!"
    }
    response = client.post("/api/v1/auth/login", data=payload)
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"
    logger.info("test_login_success", username=payload["username"])

@pytest.mark.asyncio
async def test_login_invalid_credentials(client):
    payload = {
        "username": "wronguser",
        "password": "WrongPass123!"
    }
    response = client.post("/api/v1/auth/login", data=payload)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert response.json()["detail"] == "Invalid credentials"
    logger.info("test_login_invalid_credentials")
```

```python
# backend/tests/test_scans.py
import pytest
from fastapi import status
from app.models.scan import Scan
from sqlalchemy import select
import structlog

logger = structlog.get_logger()

@pytest.mark.asyncio
async def test_create_scan(client, create_test_user, db_session):
    token = client.post("/api/v1/auth/login", data={
        "username": "testuser",
        "password": "TestPassword123!"
    }).json()["access_token"]
    
    headers = {"Authorization": f"Bearer {token}"}
    payload = {
        "target": "example.com",
        "scan_type": "web",
        "configuration": {"depth": "full"}
    }
    response = client.post("/api/v1/scans/", json=payload, headers=headers)
    assert response.status_code == status.HTTP_201_CREATED
    data = response.json()
    assert data["target"] == payload["target"]
    assert data["scan_type"] == payload["scan_type"]
    assert data["status"] == "running"
    
    result = await db_session.execute(select(Scan).filter(Scan.target == payload["target"]))
    scan = result.scalar_one_or_none()
    assert scan is not None
    logger.info("test_create_scan_success", scan_id=scan.id)

@pytest.mark.asyncio
async def test_list_scans(client, create_test_user, db_session):
    token = client.post("/api/v1/auth/login", data={
        "username": "testuser",
        "password": "TestPassword123!"
    }).json()["access_token"]
    
    headers = {"Authorization": f"Bearer {token}"}
    scan = Scan(user_id=create_test_user.id, target="example.com", scan_type="web", status="completed")
    db_session.add(scan)
    await db_session.commit()
    
    response = client.get("/api/v1/scans/", headers=headers)
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert len(data) >= 1
    assert any(s["target"] == "example.com" for s in data)
    logger.info("test_list_scans_success", count=len(data))
```

```python
# backend/requirements.txt
fastapi==0.115.2
uvicorn==0.32.0
sqlalchemy[asyncio]==2.0.35
asyncpg==0.30.0
pydantic==2.9.2
passlib[bcrypt]==1.7.4
python-jose[cryptography]==3.3.0
cryptography==43.0.3
pyotp==2.9.0
aiohttp==3.10.10
structlog==24.4.0
pdfkit==1.0.0
wkhtmltopdf==0.2
jinja2==3.1.4
pytest==8.3.3
pytest-asyncio==0.24.0
httpx==0.27.2
python-multipart==0.0.12
```

```dockerfile
# backend/Dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

RUN apt-get update && apt-get install -y wkhtmltopdf && rm -rf /var/lib/apt/lists/*

COPY . .

ENV PYTHONUNBUFFERED=1

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.9'

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://user:password@db:5432/jade_db
      - SECRET_KEY=${SECRET_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - SMTP_SERVER=${SMTP_SERVER}
      - SMTP_PORT=${SMTP_PORT}
      - SMTP_USERNAME=${SMTP_USERNAME}
      - SMTP_PASSWORD=${SMTP_PASSWORD}
      - EMAIL_FROM=${EMAIL_FROM}
      - WKHTMLTOPDF_PATH=/usr/bin/wkhtmltopdf
    volumes:
      - ./backend:/app
    depends_on:
      - db
    networks:
      - jade-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    depends_on:
      - backend
    networks:
      - jade-network

  db:
    image: postgres:16
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=jade_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - jade-network

networks:
  jade-network:
    driver: bridge

volumes:
  postgres_data:
```

```dockerfile
# frontend/Dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

CMD ["npm", "start"]
```

```json
# frontend/package.json
{
  "name": "jade-ultimate-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.27.0",
    "react-redux": "^9.1.2",
    "@reduxjs/toolkit": "^2.2.7",
    "axios": "^1.7.7",
    "react-toastify": "^10.0.5",
    "chart.js": "^4.4.4",
    "react-chartjs-2": "^5.2.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "react-scripts": "^5.0.1"
  }
}
```

```gitignore
# backend/.gitignore
__pycache__/
*.pyc
.env
logs/
*.log
*.db
venv/
*.egg-info/
dist/
build/
*.sqlite3
.pytest_cache/
coverage/
.coverage
*.bak
*.swp
*~

# frontend/.gitignore
node_modules/
build/
.env
*.log
dist/
coverage/
*.bak
*.swp
*~
```



# JADE Ultimate

JADE Ultimate is a comprehensive security scanning platform designed to identify vulnerabilities, generate detailed reports, and provide AI-driven threat analysis. This project consists of a React-based frontend and a FastAPI-based backend, with PostgreSQL as the database.

## Features

- **User Authentication**: Secure registration, login, MFA, and password reset.
- **Scan Management**: Create, view, and manage security scans.
- **Vulnerability Tracking**: Detailed vulnerability reporting with CVSS scores and remediation suggestions.
- **Report Generation**: Executive and technical PDF reports.
- **AI Analysis**: AI-driven vulnerability analysis using external APIs.
- **Dashboard**: Real-time overview of scan statuses, vulnerabilities, and threats.
- **Helpdesk**: Ticket submission for support requests.
- **Admin Panel**: Administrative controls for user and audit log management.
- **Dark/Light Mode**: Theme switching for better user experience.
- **Accessibility**: ARIA attributes and semantic HTML for accessibility compliance.

## Prerequisites

- **Docker** and **Docker Compose**
- **Node.js** (v20 or higher for frontend)
- **Python** (3.12 or higher for backend)
- **PostgreSQL** (16 or higher)
- **wkhtmltopdf** (for PDF generation)

## Setup Instructions

### 1. Clone the Repository
```bash
git clone https://github.com/your-org/jade-ultimate.git
cd jade-ultimate
```

### 2. Configure Environment Variables
Create a `.env` file in the `backend` directory with the following variables:
```env
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/jade_db
SECRET_KEY=your-secret-key-securely-generated
OPENAI_API_KEY=your-openai-api-key
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-specific-password
EMAIL_FROM=support@jadeultimate.com
WKHTMLTOPDF_PATH=/usr/bin/wkhtmltopdf
```

### 3. Build and Run with Docker Compose
```bash
docker-compose up --build
```

This will:
- Start the backend on `http://localhost:8000`
- Start the frontend on `http://localhost:3000`
- Start the PostgreSQL database

### 4. Run Without Docker
#### Backend
```bash
cd backend
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

#### Frontend
```bash
cd frontend
npm install
npm start
```

### 5. Database Migration
Ensure the database is set up:
```bash
cd backend
python -m app.models  # Run this to create tables (assumes models are imported in __init__.py)
```

## API Documentation
The API is documented using OpenAPI. Access it at `http://localhost:8000/docs` when the backend is running.

## Testing
### Backend Tests
```bash
cd backend
pytest
```

### Frontend Tests
```bash
cd frontend
npm test
```

## Project Structure
```
jade-ultimate/
├── backend/
│   ├── app/
│   │   ├── api/
│   │   ├── core/
│   │   ├── models/
│   │   ├── schemas/
│   │   ├── services/
│   │   ├── templates/
│   │   ├── utils/
│   │   └── main.py
│   ├── tests/
│   ├── Dockerfile
│   └── requirements.txt
├── frontend/
│   ├── src/
│   │   ├── components/
│   │   ├── contexts/
│   │   ├── pages/
│   │   ├── store/
│   │   ├── utils/
│   │   ├── index.js
│   │   └── index.css
│   ├── Dockerfile
│   └── package.json
├── docker-compose.yml
├── .gitignore
└── README.md
```

## Security Considerations
- **JWT Tokens**: Securely stored and validated with expiration.
- **MFA**: Optional multi-factor authentication with TOTP.
- **Password Hashing**: Uses bcrypt for secure password storage.
- **Rate Limiting**: Implement rate limiting on sensitive endpoints (e.g., login) to prevent brute force attacks.
- **CORS**: Configured to allow only trusted origins.
- **Logging**: Structured logging with `structlog` for audit trails.

## Scalability
- **Database**: PostgreSQL with asyncpg for high-performance queries.
- **Backend**: FastAPI with async endpoints for scalability.
- **Frontend**: React with Redux for state management and efficient rendering.
- **Docker**: Containerized deployment for easy scaling.

## Contributing
1. Fork the repository.
2. Create a feature branch (`git checkout -b feature/your-feature`).
3. Commit your changes (`git commit -m 'Add your feature'`).
4. Push to the branch (`git push origin feature/your-feature`).
5. Open a pull request.

## License
This project is licensed under the MIT License.

